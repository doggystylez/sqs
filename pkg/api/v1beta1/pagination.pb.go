// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sqs/query/v1beta1/pagination.proto

package v1beta1

import (
	fmt "fmt"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// PaginationStrategy is an enum that defines the pagination strategy to be used
// in the PaginationRequest request.
type PaginationStrategy int32

const (
	// unknown strategy indicates that the pagination strategy is not known
	// or not set.
	PaginationStrategy_UNKNOWN PaginationStrategy = 0
	// page-based pagination is the most common pagination strategy. It is
	// compatible with offset pagination. If you have a page of 2 and a limit of
	// 20, you will get items 20-39.
	PaginationStrategy_PAGE PaginationStrategy = 1
	// cursor-based pagination is compatible with and similar to offset
	// pagination. If you have a cursor of 50 and a limit of 20, you will get
	// items 50-69. Client should re-request all data if it changes, as the cursor
	// is not a pointer to a page, but to an item index.
	PaginationStrategy_CURSOR PaginationStrategy = 2
)

var PaginationStrategy_name = map[int32]string{
	0: "UNKNOWN",
	1: "PAGE",
	2: "CURSOR",
}

var PaginationStrategy_value = map[string]int32{
	"UNKNOWN": 0,
	"PAGE":    1,
	"CURSOR":  2,
}

func (x PaginationStrategy) String() string {
	return proto.EnumName(PaginationStrategy_name, int32(x))
}

func (PaginationStrategy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4b42ef85f330fbb5, []int{0}
}

type PaginationRequest struct {
	// page is the page number to query, starts at 0. If not provided, will
	// default to first page.
	Page uint64 `protobuf:"varint,1,opt,name=page,proto3" json:"page,omitempty"`
	// limit is the total number of results to be returned in the result page.
	// If left empty it will default to a value to be set by each app.
	Limit uint64 `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
	// cursor is the query offset to start from. If not provided, will default to
	// the 0.
	Cursor uint64 `protobuf:"varint,3,opt,name=cursor,proto3" json:"cursor,omitempty"`
	// strategy is the pagination strategy to be used. If not provided, will
	// default to PAGE.
	Strategy PaginationStrategy `protobuf:"varint,4,opt,name=strategy,proto3,enum=sqs.query.v1beta1.PaginationStrategy" json:"strategy,omitempty"`
}

func (m *PaginationRequest) Reset()         { *m = PaginationRequest{} }
func (m *PaginationRequest) String() string { return proto.CompactTextString(m) }
func (*PaginationRequest) ProtoMessage()    {}
func (*PaginationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b42ef85f330fbb5, []int{0}
}
func (m *PaginationRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PaginationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PaginationRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PaginationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PaginationRequest.Merge(m, src)
}
func (m *PaginationRequest) XXX_Size() int {
	return m.Size()
}
func (m *PaginationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PaginationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PaginationRequest proto.InternalMessageInfo

func (m *PaginationRequest) GetPage() uint64 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *PaginationRequest) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *PaginationRequest) GetCursor() uint64 {
	if m != nil {
		return m.Cursor
	}
	return 0
}

func (m *PaginationRequest) GetStrategy() PaginationStrategy {
	if m != nil {
		return m.Strategy
	}
	return PaginationStrategy_UNKNOWN
}

type PaginationResponse struct {
	// next_cursor is the cursor to be used in the next request to get the next
	// page of results for cursor-based pagination.
	// If the next_cursor is -1, it means that there are no more results to be
	// fetched.
	NextCursor int64 `protobuf:"varint,1,opt,name=next_cursor,json=nextCursor,proto3" json:"next_cursor,omitempty"`
	// total_items is the total number of items available in the result set.
	// This is useful for pagination when the client requests a subset of the
	// result set.
	TotalItems uint64 `protobuf:"varint,2,opt,name=total_items,json=totalItems,proto3" json:"total_items,omitempty"`
}

func (m *PaginationResponse) Reset()         { *m = PaginationResponse{} }
func (m *PaginationResponse) String() string { return proto.CompactTextString(m) }
func (*PaginationResponse) ProtoMessage()    {}
func (*PaginationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4b42ef85f330fbb5, []int{1}
}
func (m *PaginationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PaginationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PaginationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PaginationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PaginationResponse.Merge(m, src)
}
func (m *PaginationResponse) XXX_Size() int {
	return m.Size()
}
func (m *PaginationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PaginationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PaginationResponse proto.InternalMessageInfo

func (m *PaginationResponse) GetNextCursor() int64 {
	if m != nil {
		return m.NextCursor
	}
	return 0
}

func (m *PaginationResponse) GetTotalItems() uint64 {
	if m != nil {
		return m.TotalItems
	}
	return 0
}

func init() {
	proto.RegisterEnum("sqs.query.v1beta1.PaginationStrategy", PaginationStrategy_name, PaginationStrategy_value)
	proto.RegisterType((*PaginationRequest)(nil), "sqs.query.v1beta1.PaginationRequest")
	proto.RegisterType((*PaginationResponse)(nil), "sqs.query.v1beta1.PaginationResponse")
}

func init() {
	proto.RegisterFile("sqs/query/v1beta1/pagination.proto", fileDescriptor_4b42ef85f330fbb5)
}

var fileDescriptor_4b42ef85f330fbb5 = []byte{
	// 325 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x64, 0x91, 0xc1, 0x6a, 0xf2, 0x40,
	0x14, 0x85, 0x33, 0x9a, 0xdf, 0x5f, 0xae, 0x50, 0x74, 0x28, 0x25, 0xab, 0x28, 0x42, 0x41, 0x5a,
	0x9a, 0x60, 0xbb, 0xe8, 0xda, 0x8a, 0x94, 0x52, 0x50, 0x89, 0xd8, 0x42, 0x37, 0x32, 0x91, 0x21,
	0x1d, 0x6a, 0x32, 0x49, 0xee, 0xa4, 0xd4, 0xb7, 0xe8, 0xb2, 0x8f, 0xd4, 0xa5, 0xcb, 0x2e, 0x8b,
	0xbe, 0x48, 0xc9, 0x18, 0xad, 0xd0, 0x5d, 0xee, 0xc7, 0xc9, 0x7c, 0x07, 0x0e, 0xb4, 0x31, 0x41,
	0x37, 0xc9, 0x78, 0xba, 0x74, 0x5f, 0xbb, 0x3e, 0x57, 0xac, 0xeb, 0xc6, 0x2c, 0x10, 0x11, 0x53,
	0x42, 0x46, 0x4e, 0x9c, 0x4a, 0x25, 0x69, 0x03, 0x13, 0x74, 0x74, 0xc6, 0x29, 0x32, 0xed, 0x0f,
	0x02, 0x8d, 0xf1, 0x3e, 0xe7, 0xf1, 0x24, 0xe3, 0xa8, 0x28, 0x05, 0x33, 0x66, 0x01, 0xb7, 0x48,
	0x8b, 0x74, 0x4c, 0x4f, 0x7f, 0xd3, 0x63, 0xf8, 0xb7, 0x10, 0xa1, 0x50, 0x56, 0x49, 0xc3, 0xed,
	0x41, 0x4f, 0xa0, 0x32, 0xcf, 0x52, 0x94, 0xa9, 0x55, 0xd6, 0xb8, 0xb8, 0x68, 0x0f, 0xaa, 0xa8,
	0x52, 0xa6, 0x78, 0xb0, 0xb4, 0xcc, 0x16, 0xe9, 0x1c, 0x5d, 0x9e, 0x3a, 0x7f, 0xec, 0xce, 0xaf,
	0x79, 0x52, 0x84, 0xbd, 0xfd, 0x6f, 0xed, 0x07, 0xa0, 0x87, 0xcd, 0x30, 0x96, 0x11, 0x72, 0xda,
	0x84, 0x5a, 0xc4, 0xdf, 0xd4, 0xac, 0xb0, 0xe6, 0x0d, 0xcb, 0x1e, 0xe4, 0xa8, 0xbf, 0x35, 0x37,
	0xa1, 0xa6, 0xa4, 0x62, 0x8b, 0x99, 0x50, 0x3c, 0xc4, 0xa2, 0x2d, 0x68, 0x74, 0x97, 0x93, 0xb3,
	0xeb, 0xc3, 0x77, 0x77, 0x5e, 0x5a, 0x83, 0xff, 0xd3, 0xe1, 0xfd, 0x70, 0xf4, 0x38, 0xac, 0x1b,
	0xb4, 0x0a, 0xe6, 0xb8, 0x77, 0x3b, 0xa8, 0x13, 0x0a, 0x50, 0xe9, 0x4f, 0xbd, 0xc9, 0xc8, 0xab,
	0x97, 0x6e, 0x06, 0x9f, 0x6b, 0x9b, 0xac, 0xd6, 0x36, 0xf9, 0x5e, 0xdb, 0xe4, 0x7d, 0x63, 0x1b,
	0xab, 0x8d, 0x6d, 0x7c, 0x6d, 0x6c, 0xe3, 0xe9, 0x3c, 0x10, 0xea, 0x39, 0xf3, 0x9d, 0xb9, 0x0c,
	0x5d, 0x89, 0xa1, 0x44, 0x81, 0x17, 0x0b, 0xe6, 0xa3, 0x9b, 0x8f, 0x12, 0xbf, 0x04, 0x2e, 0x8b,
	0xc5, 0x6e, 0x16, 0xbf, 0xa2, 0xc7, 0xb8, 0xfa, 0x09, 0x00, 0x00, 0xff, 0xff, 0xf2, 0x00, 0x56,
	0x18, 0xb2, 0x01, 0x00, 0x00,
}

func (m *PaginationRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PaginationRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PaginationRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Strategy != 0 {
		i = encodeVarintPagination(dAtA, i, uint64(m.Strategy))
		i--
		dAtA[i] = 0x20
	}
	if m.Cursor != 0 {
		i = encodeVarintPagination(dAtA, i, uint64(m.Cursor))
		i--
		dAtA[i] = 0x18
	}
	if m.Limit != 0 {
		i = encodeVarintPagination(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x10
	}
	if m.Page != 0 {
		i = encodeVarintPagination(dAtA, i, uint64(m.Page))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PaginationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PaginationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PaginationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalItems != 0 {
		i = encodeVarintPagination(dAtA, i, uint64(m.TotalItems))
		i--
		dAtA[i] = 0x10
	}
	if m.NextCursor != 0 {
		i = encodeVarintPagination(dAtA, i, uint64(m.NextCursor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintPagination(dAtA []byte, offset int, v uint64) int {
	offset -= sovPagination(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PaginationRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Page != 0 {
		n += 1 + sovPagination(uint64(m.Page))
	}
	if m.Limit != 0 {
		n += 1 + sovPagination(uint64(m.Limit))
	}
	if m.Cursor != 0 {
		n += 1 + sovPagination(uint64(m.Cursor))
	}
	if m.Strategy != 0 {
		n += 1 + sovPagination(uint64(m.Strategy))
	}
	return n
}

func (m *PaginationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NextCursor != 0 {
		n += 1 + sovPagination(uint64(m.NextCursor))
	}
	if m.TotalItems != 0 {
		n += 1 + sovPagination(uint64(m.TotalItems))
	}
	return n
}

func sovPagination(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPagination(x uint64) (n int) {
	return sovPagination(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PaginationRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPagination
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PaginationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PaginationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPagination
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPagination
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cursor", wireType)
			}
			m.Cursor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPagination
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cursor |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strategy", wireType)
			}
			m.Strategy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPagination
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Strategy |= PaginationStrategy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPagination(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPagination
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PaginationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPagination
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PaginationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PaginationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextCursor", wireType)
			}
			m.NextCursor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPagination
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextCursor |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalItems", wireType)
			}
			m.TotalItems = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPagination
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalItems |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPagination(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPagination
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPagination(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPagination
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPagination
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPagination
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPagination
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPagination
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPagination
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPagination        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPagination          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPagination = fmt.Errorf("proto: unexpected end of group")
)
